добавить тестовый api оплаты от юкассы, после оплаты статус заказа менять:

для начала внести общие поправки с сика + исправить появление флешек на оформлении заказа после оплаты

использовать холдирование средств, чтобы была возможность отмены заказа сразу после оплаты

сейчас почему то пришлось скрипт для кнопки перенести на страницу, плюс куча коменнтов и изменений которые я не смотрел, все почистить и исправить, еще страницу успеха тупо из сика вставил, 
посмотреть что конкретно он поменял (исправил), с бека сделать только эти нужные изменения. еще статус в бд остаеться pending_payment и при повторном заказазе висит ошибка оплата не найдена в бд,
при выходе из оплаты пропадают товары из корзины (слишком рано статус меняеться на pending или нет смены этого статуса на cart), вебхук тоже менял
плюс еще не задерживаюсь почему-то на странице успеха (т к вебхук почему то не работает, может из-за тонеля, и не меняеться статус на paid)
ссылка на сайт все таки меняется, ее надо менять как минимум в create_payment.php и в юкассе

сделать страницу "мои заказы" или типо того, на странице возможность отменить заказ

номер телефона плюс почта, и добавить двухфакторку через нее

поиск товаров в хедере

внести в бд побольше товаров 

наверное очищать старые заказы (со статусом cart)

кешироание, логирование, Rate Limiting через redis, lazyLoad и скелетоны

пройтись везде sonar qube for ide (расширение для поиска уязвимостей)

пройтись везде низким интернетом и посмотреть что исправить










способ получения

страница оформления наверное должна называться checkout
рядом с кнопкой добавить в корзину поставть кнопку сразу купить

у меня установлено choco, node js, ngrok, Cloudflar, composer, рабочий тунель: ssh -R 80:localhost:80 nokey@54.161.197.247 или пробовать такой ssh -i "C:\Users\mocus\OneDrive\Рабочий стол\ssh-keys\id_rsa" -R bossOfThisGym:80:localhost:80 54.161.197.247
   
возможно использовать фреймворки (Laravel)

использовать семнатическую верстку (правильные по смыслу теги вместо одних div, также h1, h2 и т д) -> в сике (Семантические теги)

для второго сайта парральельно с сатйом делать админку (использовать по возможности готовые решения, хотя бы с интерфейсом)

структуру бд и некоторую логику для второго сайта поменять, в сике чат "структура бд для 2 им"

сначала юзер в корзине нажимает "оформить заказ", потом уведомление/страница "заказ оформлен" с кнопкой "оплатить" и статус его в бд меняется на "оформлен", потом юзер оплачивает 
и статус меняется на "оплачен", вместе с этим нужно сохранять время и оформления и оплаты, потом рассчитывать время доставки и т д, также может быть статус "ожидает оплаты"

использовать flash сообщения (система кодов ошибок (КАПСОМ_ЧЕРЕЗ_) + функция преобразования), для этого использовать универсальные функции в utils.js (для Ошибок оплаты, Успешных действий ("Заказ создан"), Предупреждений ("Товар добавлен в корзину"), Информационных сообщений)
модалки - критичное, flash - не критичное

вмпесто src именовать ajax, вместо helpers сделать отдельную папку config, в ней поделючение к бд и ключи/пароли, работать должна через proxy

для формы регистрации: кнопка "уже зарег-ны? -> войти в аккаунт"

для процессов, которые могут законно завершиться ошибкой, зависят от внешних факторов, критичны для работы приложени яделать логирование всех ошибок, процессы проводить через try {  throw new Exception('Database connection failed'); } catch (Exception $e)

прдумать логику правильной загрузки при плохом интернете (через панель разработчика)

лоадеры только для долгих операций (карты, отправка формы заказа, оплата), а для изображений lazy loading и скелетоны (все скелетоны сразу для всей страницы/секции, а потом одномоментно заменял их всеми реальными данными.)

добавлять транзакцию для запросов к бд (например если удаление аккаунта - последовательно удаляем из всех таблиц) и ооткатываем изменения при неудаче

все ответы от api должны быть в json формате

при работе с бд проверить удалось ли if ($stmt) {$stmt->bind_param("i", $idUser); }

нужен utils.js (функции для 2+ страниц)

для скриптов добавлять defer (кроме случаев когда скрипт до начала рендеринга страницы (критический для отображения), до других скриптов (и является для них зависимостью) сторонние сервисы/API, которые ТРЕБУЮТ немедленного выполнения (а не все подряд))

функция fetchWithRetry для fetch которые что-то меняют (для get не надо), убираем ответ js при этом тк он в фунции уже есть - это повторные запросы к API

использовать кеширование (и сброс кэша через админку), кешировать главную страницу, страницы категорий, статические страницы

использовать email рассылку, для регестрации, заказов и опции "забыл пароль" (если sms, то https://smsc.ru/)

для input в формах добавлять name и autocomplete

код для ревью Сику и потом Славе и Вове

для путей использоать _DIR_ с /



Особенность	        	include          		require_once
Если файл не найден		Предупреждение	          	Фатальная ошибка
Многократное подключение		Да			Нет
Подходит для		    Шаблоны,необязательные файлы	Критически важные файлы



для второй версии сайта: - для фронта, _ для бека , сео, одна страница товара и подгрузка id, подгрузка изображений, называть классы и все
остальное абстрактно (без привязки к названию страниц), подключить гит, админка, подключение к бд и полученние необходимых данных вынести в отдельный файл,
нужны универсальные функции для добавления в корзину, изменения счётчиков, подсчёта суммы заказа и т д по айди и дата-атрибутам УНИВЕРСАЛЬНЫЕ, добавить и использовать 
фотку-заглушку, при переходе по страницам через стрелочки обнавлять счётчик в хедере, использовать сокращения (btn), таблица и работа промокодов, отдельные страницы для категорий,
продумать как правильно защищать пароли и данные пользователей, использовать уневирсальные названия для классов, использовать проценты, границы и тени всегда %, шрифты - rem,
 
серевер общаеться со страницей через json, в нем сравниваем message и показываем для каждого message своё

при работе с DOM-элементами, особенно: document.querySelector() / document.getElementById() - могут вернуть null 
e.target.parentElement - может быть null e.target.closest() - может быть null Любые цепочки свойств через точку использовать проверку на null (element?.classList.add('class');) 
Нужно использовать ?. только в цепочках свойств, где есть риск встретить null или undefined.

посмотреть какие есть class:разновидность, например .map_search_input:focus { border-color: #007bff; } поисковая строка подсвечивается синим при использовании.

добавлять проверки для api endpoint

для выбора - <select> + <option>

использовать БЭМ и правильное название сущностей (https://habr.com/ru/companies/ruvds/articles/347194)

если вставлять фотку на фон то background: url("./img/header_button_click.svg") no-repeat center / 100% 100%;

left: 50%; transform: translateX(-50%); для сложных случаев, а для простых margin-left: auto; margin-right: auto;

уневерсальные функции (например получение из бд данных)

проверять авторизацию даже на страницах куда неавторизированный пользователь не имеет ссылки (может выкинуть со временем),
проверять где нужны персональные данные пользователя или совершение действий от его имени, работают с персональными данными,
выполняют изменения в БД от имени пользователя, возвращают чувствительную информацию

в джаве можно динамически создавать элементы и добавлять/удалять классы элементов

тернарный оператор: updateDeliveryTypeInDB(isDelivery ? 'delivery' : 'pickup');
isDelivery - условие (true/false)
? - разделитель условия и результатов
'delivery' - значение если условие true
: - разделитель вариантов
'pickup' - значение если условие false

расширения из диолога с Паштетом

всегда проверять нажатие той же кнопки (если нажали ту же, т о ничего не выпонляем), например в выборе типа доставки на моем сайте

Вместо блокнота обсидиан


По теории проходиться:
Знание сетей, принципах работы интернетах протоколов, видов атак на них
Базовые знание модели OSI, стек TCP/IP
Навыки: Python/Базовый SQL/Базовый-Средний C++/Работал с HTML+CSS
Работа с инструментами: Навыки анализа данных на платформе Yandex DataLens 
Базовые знания основных веб уязвимостей(OWASP TOP 10)
Базовые знания Linux/Windows
Знания нормативной базы в сфере Иб: ФЗ-152, ФЗ-187, ФЗ-63, ГОСТ 57850.1, ГОСТ 57001, ISO/IEC 27001, ФСТЭК 235,239,17
Грамотная устная и письменная речь 
Умение работать в команде
Знание английского языка на уровне чтения и перевода технической документации
Понимание тактик компьютерных атак и их обнаружения 
Участвовал в CTF/Хакатон

шпаргалка по HTTP-заголовкам:

Vary --> Список описывающих ресурс полей из запроса, которые были приняты во внимание.  

Via --> Список версий протокола, названий и версий прокси-серверов, через которых прошло сообщение.

Warning --> Код, агент, сообщение и дата, если возникла критическая ситуация.  

WWW-Authenticate --> Параметры аутентификации для выполнения метода к указанному ресурсу.

Accept --> Список допустимых форматов ресурса.

Accept-Charset --> Перечень поддерживаемых кодировок для предоставления пользователю.

Accept-Encoding --> Перечень поддерживаемых способов кодирования содержимого сущности при передаче.

Accept-Language --> Список поддерживаемых естественных языков.

Accept-Ranges --> Перечень единиц измерения диапазонов.

Age --> Количество секунд с момента модификации ресурса.

Allow --> Список поддерживаемых методов.

Alternates --> альтернативные способы представления ресурса.

Authorization --> Данные для авторизации.

Cache-Control --> Основные директивы для управления кэшированием.

Connection --> Сведения о проведении соединения.

Content-Base --> Сведения о постоянном местонахождении ресурса. Убрано в HTTP/1.1v2.

Content-Disposition --> Способ распределения сущностей в сообщении при передаче нескольких фрагментов.

Content-Encoding --> Способ кодирования содержимого сущности при передаче.

Content-Language --> Один или несколько естественных языков содержимого сущности.

Content-Length --> Размер содержимого сущности в октетах (которые в русском языке обычно называют байтами).

Content-Location --> Альтернативное расположение содержимого сущности.

Content-MD5 --> Base64 MD5-хэша сущности для проверки целостности.

Content-Range --> Байтовые диапазоны передаваемой сущности если возвращается фрагмент. Подробности: Частичные GET.

Content-Type --> Формат и способ представления сущности.

Content-Version --> Информация о текущей версии сущности.

Date --> Дата генерации отклика.

Derived-From --> Информация о текущей версии сущности.

ETag --> Тег (уникальный идентификатор) версии сущности, используемый при кэшировании.

Expect --> Указывает серверу что клиент ожидает от него дополнительного действия.

Expires --> Дата предполагаемого истечения срока актуальности сущности.

From --> Адрес электронной почты ответственного лица со стороны клиента.

Host --> Доменное имя и порт хоста запрашиваемого ресурса. Необходимо для поддержки виртуального хостинга на серверах.  

If-Match --> Список тегов версий сущности. Выполнять метод, если они существуют.    

If-Modified-Since --> Дата. Выполнять метод если сущность изменилась с указанного момента.

If-None-Match --> Список тегов версий сущности. Выполнять метод если ни одного из них не существует.

If-Range --> Список тегов версий сущности или дата для определённого фрагмента сущности.

If-Unmodified-Since --> Дата. Выполнять метод если сущность не изменилась с указанной даты.

Last-Modified --> Дата последней модификации сущности.

Link --> Указывает на логически связанный с сущностью ресурс аналогично тегу <LINK> в HTML.

Location --> URI по которому клиенту следует перейти или URI созданного ресурса.    

Max-Forwards --> Максимально допустимое количество переходов через прокси.

MIME-Version --> Версия протокола MIME, по которому было сформировано сообщение.

Pragma --> Особенные опции выполнения операции.

Proxy-Authenticate --> Параметры аутентификации на прокси-сервере.

Proxy-Authorization --> Информация для авторизации на прокси-сервере.  

Public --> Список доступных методов аналогично Allow, но для всего сервера.

Range --> Байтовые диапазоны для запроса фрагментов ресурса. Подробности: Частичные GET.

Referer --> URI ресурса, после которого клиент сделал текущий запрос.  

Retry-After --> Дата или время в секундах после которого можно повторить запрос.

Server --> Список названий и версий веб-сервера и его компонентов с комментариями. Для прокси-серверов поле Via.    

Title --> Заголовок сущности.

TE --> Список расширенных способов кодирования при передаче.    

Trailer --> Список полей, имеющих отношение к кодированию сообщения при передаче.

Transfer-Encoding --> Список способов кодирования, которые были применены к сообщению для передачи.

Upgrade --> Список предлагаемых клиентом протоколов. Сервер указывает один протокол.

URI --> Список URI. В HTTP/1.1 заменено на Location, Content-Location, Vary и Link.

User-Agent --> Список названий и версий клиента и его компонентов с комментариями.  

Vary --> Список описывающих ресурс полей из запроса, которые были приняты во внимание.  

Via --> Список версий протокола, названий и версий прокси-серверов, через которых прошло сообщение.

Warning --> Код, агент, сообщение и дата, если возникла критическая ситуация.  

WWW-Authenticate --> Параметры аутентификации для выполнения метода к указанному ресурсу.



sonar qube for ide (расширение для поиска уязвимостей)